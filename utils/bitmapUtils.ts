import { ByteOrder, ScanMode } from "../types";

// Convert 1D pixel array to C Array string
export const generateCArray = (
  pixels: Uint8Array,
  width: number,
  height: number,
  scanMode: ScanMode,
  byteOrder: ByteOrder,
  varName: string = "bitmap"
): string => {
  let output = `// ${width}x${height} bitmap generated by LCD Matrix Studio\n`;
  output += `const unsigned char ${varName} [] PROGMEM = {\n`;
  
  const bytes: string[] = [];
  
  if (scanMode === ScanMode.HORIZONTAL_RASTER) {
    // Rows of bytes. 8 pixels per byte horizontally.
    const bytesPerRow = Math.ceil(width / 8);
    for (let y = 0; y < height; y++) {
      for (let b = 0; b < bytesPerRow; b++) {
        let byte = 0;
        for (let i = 0; i < 8; i++) {
          const x = b * 8 + i;
          if (x < width) {
            const pixelVal = pixels[y * width + x];
            if (byteOrder === ByteOrder.MSB_FIRST) {
              if (pixelVal) byte |= (1 << (7 - i));
            } else {
              if (pixelVal) byte |= (1 << i);
            }
          }
        }
        bytes.push(`0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);
      }
    }
  } else if (scanMode === ScanMode.VERTICAL_PAGE) {
    // Columns of bytes (SSD1306 style). 8 pixels per byte vertically.
    // Iterates x then y-pages.
    const pages = Math.ceil(height / 8);
    for (let p = 0; p < pages; p++) {
      for (let x = 0; x < width; x++) {
        let byte = 0;
        for (let i = 0; i < 8; i++) {
          const y = p * 8 + i;
          if (y < height) {
            const pixelVal = pixels[y * width + x];
             // Standard SSD1306: LSB is top (y%8==0), MSB is bottom (y%8==7)
             // But let's respect the byteOrder setting for flexibility, though LSB_FIRST is standard here.
            if (byteOrder === ByteOrder.LSB_FIRST) {
               if (pixelVal) byte |= (1 << i);
            } else {
               if (pixelVal) byte |= (1 << (7 - i));
            }
          }
        }
        bytes.push(`0x${byte.toString(16).padStart(2, '0').toUpperCase()}`);
      }
    }
  }

  // Formatting output
  const bytesPerLine = 12;
  for (let i = 0; i < bytes.length; i += bytesPerLine) {
    output += "  " + bytes.slice(i, i + bytesPerLine).join(", ");
    if (i + bytesPerLine < bytes.length) output += ",";
    output += "\n";
  }

  output += "};\n";
  return output;
};

// Convert image file to pixel data
export const processImageFile = async (
    file: File, 
    targetWidth: number, 
    targetHeight: number, 
    threshold: number = 128
): Promise<Uint8Array> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                const ctx = canvas.getContext('2d');
                if (!ctx) return reject("Canvas context error");

                // Draw image resized (naive resizing)
                ctx.fillStyle = 'white'; // Default background
                ctx.fillRect(0, 0, targetWidth, targetHeight);
                
                // Preserve aspect ratio fit
                const scale = Math.min(targetWidth / img.width, targetHeight / img.height);
                const w = img.width * scale;
                const h = img.height * scale;
                const x = (targetWidth - w) / 2;
                const y = (targetHeight - h) / 2;
                
                ctx.drawImage(img, x, y, w, h);
                
                const imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);
                const data = imageData.data;
                const pixels = new Uint8Array(targetWidth * targetHeight);

                for (let i = 0; i < pixels.length; i++) {
                    const r = data[i * 4];
                    const g = data[i * 4 + 1];
                    const b = data[i * 4 + 2];
                    const a = data[i * 4 + 3];

                    // Luminance calculation
                    const brightness = (0.299 * r + 0.587 * g + 0.114 * b);
                    
                    if (a < 128) {
                        pixels[i] = 0;
                    } else {
                        pixels[i] = brightness < threshold ? 1 : 0;
                    }
                }
                resolve(pixels);
            };
            img.onerror = reject;
            img.src = e.target?.result as string;
        };
        reader.readAsDataURL(file);
    });
};

export const parseCArray = (
  text: string, 
  width: number, 
  height: number,
  scanMode: ScanMode,
  byteOrder: ByteOrder
): Uint8Array | null => {
  // Find everything between { and }
  const match = text.match(/\{([\s\S]*)\}/);
  if (!match) return null;
  
  const content = match[1];
  // Extract hex numbers
  const hexValues = content.match(/0x[0-9A-Fa-f]{1,2}|[0-9]+/g);
  if (!hexValues) return null;
  
  const bytes = hexValues.map(v => parseInt(v, 16));
  const pixels = new Uint8Array(width * height);
  
  let byteIdx = 0;

  if (scanMode === ScanMode.HORIZONTAL_RASTER) {
      const bytesPerRow = Math.ceil(width / 8);
      for (let y = 0; y < height; y++) {
          for (let b = 0; b < bytesPerRow; b++) {
              if (byteIdx >= bytes.length) break;
              const byte = bytes[byteIdx++];
              
              for (let i = 0; i < 8; i++) {
                  const x = b * 8 + i;
                  if (x < width) {
                      let bitVal = 0;
                      if (byteOrder === ByteOrder.MSB_FIRST) {
                          bitVal = (byte >> (7 - i)) & 1;
                      } else {
                          bitVal = (byte >> i) & 1;
                      }
                      pixels[y * width + x] = bitVal;
                  }
              }
          }
      }
  } else if (scanMode === ScanMode.VERTICAL_PAGE) {
      const pages = Math.ceil(height / 8);
      for (let p = 0; p < pages; p++) {
          for (let x = 0; x < width; x++) {
              if (byteIdx >= bytes.length) break;
              const byte = bytes[byteIdx++];
              
              for (let i = 0; i < 8; i++) {
                  const y = p * 8 + i;
                  if (y < height) {
                      let bitVal = 0;
                      if (byteOrder === ByteOrder.LSB_FIRST) {
                          bitVal = (byte >> i) & 1;
                      } else {
                          bitVal = (byte >> (7 - i)) & 1;
                      }
                      pixels[y * width + x] = bitVal;
                  }
              }
          }
      }
  }

  return pixels;
}